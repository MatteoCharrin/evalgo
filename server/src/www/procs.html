<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <title>Processus — multi-agents</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    :root { color-scheme: light dark; }
    body { margin:0; padding:24px; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; background:canvas; color:canvastext; }
    .wrap { max-width:1600px; margin:0 auto; display:grid; gap:16px; grid-template-columns: repeat(auto-fit, minmax(520px, 1fr)); }
    .card { padding:16px 20px; border:1px solid color-mix(in oklab, canvastext 15%, transparent); border-radius:16px; background:color-mix(in oklab, canvas 92%, canvastext 0%); box-shadow:0 1px 8px color-mix(in oklab, canvastext 10%, transparent); }
    h1 { margin:0 0 8px; font-size:1.25rem; }
    h2 { margin:0 0 10px; font-size:1.05rem; }
    .muted { opacity:.75; font-size:.9rem; }
    .toolbar { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    input[type="text"], select { padding:6px 8px; border-radius:10px; border:1px solid color-mix(in oklab, canvastext 25%, transparent); background: color-mix(in oklab, canvas 95%, canvastext 0%); color:inherit; }
    .pill { display:inline-block; padding:.1rem .45rem; border-radius:.75rem; border:1px solid color-mix(in oklab, canvastext 25%, transparent); font-size:.85rem; }
    .btn { padding:4px 8px; border-radius:8px; border:1px solid color-mix(in oklab, crimson 45%, transparent); background: color-mix(in oklab, crimson 35%, canvas); color:white; cursor:pointer; }
    .btn.small { padding:3px 6px; font-size:.85rem; }
    .btn[disabled]{ opacity:.6; cursor:default; }
    table { width:100%; border-collapse:collapse; }
    th, td { padding:8px 10px; border-bottom:1px solid color-mix(in oklab, canvastext 12%, transparent); text-align:left; vertical-align:top; }
    th { font-weight:600; }
    .right { text-align:right; }
    .mono { font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size:.9rem; }
    .nowrap { white-space:nowrap; }
    .head { display:flex; align-items:center; gap:10px; }
  </style>
</head>
<body>
  <div class="wrap">
    <section class="card">
      <div class="head">
        <h1>Processus — multi-agents</h1>
        <span class="muted">Source : <code>/api/procs</code> · Kill via <code>/api/agents/{id}/procs/kill/{pid}</code></span>
      </div>
      <div class="toolbar" style="margin-top:8px">
        <label>Filtrer :
          <input id="q" type="text" placeholder="nom, utilisateur, cmdline…">
        </label>
        <label>Statut :
          <select id="status">
            <option value="">(tous)</option>
            <option value="R">R</option>
            <option value="S">S</option>
            <option value="I">I</option>
            <option value="D">D</option>
            <option value="T">T</option>
            <option value="Z">Z</option>
          </select>
        </label>
        <label>
          Auto-refresh
          <select id="auto">
            <option value="0">off</option>
            <option value="2000">2s</option>
            <option value="5000" selected>5s</option>
            <option value="10000">10s</option>
          </select>
        </label>
        <span id="ts" class="muted"></span>
      </div>
    </section>

    <div id="root" class="wrap"></div>
  </div>

  <script>
    // --- utils ---
    function esc(s){return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;')
      .replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;')}
    function fmtBytes(n){ n=Number(n)||0; const u=['B','KiB','MiB','GiB','TiB']; let i=0;
      while(n>=1024 && i<u.length-1){ n/=1024; i++; }
      return n.toFixed(n<10?2:n<100?1:0)+' '+u[i];
    }
    function fmtTimeMs(ms){ const d=new Date(Number(ms)||0); return Number(ms)? d.toLocaleString():'' }

    // --- state ---
    let ALL = []; // [{id, host, url, data:[...], err}]
    let timer = null;

    async function fetchAll(){
      const res = await fetch('/api/procs', {headers:{'Accept':'application/json'}, cache:'no-store'});
      if(!res.ok) throw new Error('HTTP '+res.status);
      const data = await res.json();
      if(!Array.isArray(data)) throw new Error('format invalide');
      ALL = data;
      document.getElementById('ts').textContent = 'Mis à jour : ' + new Date().toLocaleTimeString();
    }

    // --- rendering ---
    function render(){
      const root = document.getElementById('root');
      const q = (document.getElementById('q').value || '').toLowerCase();
      const st = document.getElementById('status').value || '';

      if(!Array.isArray(ALL) || ALL.length === 0){
        root.innerHTML = '<section class="card"><div class="muted">Aucun agent</div></section>';
        return;
      }

      root.innerHTML = ALL.map(it => renderAgentCard(it, q, st)).join('');
    }

    function renderAgentCard(it, q, st){
      if(it.err){
        return '<section class="card"><h2>'+esc(it.host)+' ('+esc(it.id)+')</h2>'
             + '<div class="muted">Erreur: '+esc(it.err)+'</div></section>';
      }
      const rows = renderRows(it.id, Array.isArray(it.data)? it.data: [], q, st);
      const count = rows.count;
      return '<section class="card">'
        + '<h2>'+esc(it.host)+' ('+esc(it.id)+')</h2>'
        + '<div class="muted" style="margin-bottom:8px">'+count+' processus affichés</div>'
        + '<table><thead><tr>'
        + '<th class="right">PID</th>'
        + '<th>Nom</th>'
        + '<th>Statut</th>'
        + '<th>Utilisateur</th>'
        + '<th class="right">Threads</th>'
        + '<th class="right">RSS</th>'
        + '<th class="right">VMS</th>'
        + '<th class="nowrap">Créé</th>'
        + '<th>Cmdline</th>'
        + '<th class="right">Actions</th>'
        + '</tr></thead><tbody>'+rows.html+'</tbody></table>'
        + '</section>';
    }

    function renderRows(agentId, items, q, st){
      let out = [];
      let shown = 0;
      for(const x of items){
        const hay = (x.name||'')+' '+(x.username||'')+' '+(x.cmdline||'');
        if(q && hay.toLowerCase().indexOf(q) === -1) continue;
        if(st && (x.status||'') !== st) continue;
        shown++;
        out.push(
          '<tr>'
          + '<td class="right mono">'+esc(x.pid)+'</td>'
          + '<td class="mono">'+esc(x.name||'')+'</td>'
          + '<td class="nowrap"><span class="pill">'+esc(x.status||'')+'</span></td>'
          + '<td>'+esc(x.username||'')+'</td>'
          + '<td class="right mono">'+esc(x.threads||'')+'</td>'
          + '<td class="right mono">'+esc(fmtBytes(x.memory_rss))+'</td>'
          + '<td class="right mono">'+esc(fmtBytes(x.memory_vms))+'</td>'
          + '<td class="nowrap mono">'+esc(fmtTimeMs(x.create_time))+'</td>'
          + '<td class="mono">'+esc(x.cmdline||'')+'</td>'
          + '<td class="right">'
            + '<button class="btn small" onclick="killProc(\''+encodeURIComponent(agentId)+'\','+Number(x.pid)+', this)">Kill</button>'
          + '</td>'
          + '</tr>'
        );
      }
      if(shown === 0){
        out = ['<tr><td colspan="10" class="muted">Aucun processus ne correspond aux filtres</td></tr>'];
      }
      return { html: out.join(''), count: shown };
    }

    // --- actions ---
    async function killProc(agentIdEncoded, pid, btn){
      try{
        if(!pid) return;
        const agentId = decodeURIComponent(agentIdEncoded);
        const ok = confirm('Tuer le PID '+pid+' sur '+agentId+' ?');
        if(!ok) return;
        const prev = btn.textContent;
        btn.disabled = true; btn.textContent = '…';
        const url = '/api/agents/'+encodeURIComponent(agentId)+'/procs/kill/'+encodeURIComponent(String(pid));
        const res = await fetch(url, {method:'GET', cache:'no-store'});
        if(!res.ok){
          const txt = await res.text().catch(()=> '');
          throw new Error('Kill échoué ('+res.status+'): '+txt);
        }
        // Recharger la liste après kill
        await fetchAll();
        render();
      }catch(e){
        alert(e.message || String(e));
      }finally{
        if(btn){ btn.disabled = false; btn.textContent = 'Kill'; }
      }
    }
    window.killProc = killProc; // exposer pour onclick

    // --- wiring ---
    document.getElementById('q').addEventListener('input', render);
    document.getElementById('status').addEventListener('change', render);
    document.getElementById('auto').addEventListener('change', function(){
      if(timer) { clearInterval(timer); timer = null; }
      const ms = Number(this.value)||0;
      if(ms>0){
        timer = setInterval(async ()=>{ try{ await fetchAll(); render(); }catch{} }, ms);
      }
    });

    // premier chargement
    (async function init(){
      try{ await fetchAll(); } catch(e){ /* affichage quand même */ }
      render();
      // activer l'auto-refresh par défaut (5s)
      document.getElementById('auto').dispatchEvent(new Event('change'));
    })();
  </script>
</body>
</html>
